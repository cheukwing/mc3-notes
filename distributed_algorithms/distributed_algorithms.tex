\documentclass[11pt]{article}
\usepackage{fullpage}
\usepackage{amsthm}
\usepackage{amsmath} \usepackage{amssymb}
\usepackage{graphicx}

\graphicspath{ {./imgs/} }

\setlength{\parindent}{0pt}

\title{Distributed Algorithms (CO347)}
\author{Michael Tsang}

\newtheorem{defn}{Definition}
\newtheorem{eg}{Example}
\newtheorem{theo}{Theorem}
\newtheorem{lem}{Lemma}

\begin{document}

\maketitle
\section{Motivation}
\subsection{Why a Distributed System?}
\begin{itemize}
  \item Computation and data distribution.
  \item Performance through parallelisation and distribution.
  \item Reliability and availability through replication, fault-tolerance, security.
  \item Scalability, modularity, evolvability.
  \item Heterogenity of hardware and software.
\end{itemize}

\subsection{What is a Distributed System?}
\begin{itemize}
  \item A set of processes connected by a network.
    \begin{itemize}
      \item Machines can be located across the planet.
      \item Communicate via message passing, no shared memory.
    \end{itemize}
  \item No common physical clock.
    \begin{itemize}
      \item No total order on events by time.
    \end{itemize}
\end{itemize}

\subsection{Assumptions}
When designing distributed systems, we have to consider different assumptions.

\subsubsection{Timing}
\begin{itemize}
  \item \textbf{Synchronous systems}:
    \begin{itemize}
      \item Upper bound on process delays.
      \item Upper bound on time for a message to be delivered.
      \item Can translate results to asynchronous models.
    \end{itemize}
  \item \textbf{Asynchronous systems}:
    \begin{itemize}
      \item Processes and communication take arbitrary time.
      \item No assumption that processes have physical clocks, but can be useful to use logical clocks.
    \end{itemize}
  \item \textbf{Partially synchronous systems}:
    \begin{itemize}
      \item Real-world systems are mostly synchronous with asynchronous periods.
      \item Assume the system is eventutally synchronous.
    \end{itemize}
\end{itemize}

\subsubsection{Failures}
\begin{itemize}
  \item \textbf{No failures}:
    \begin{itemize}
      \item Unrealistic.
    \end{itemize}
  \item \textbf{Process failure}:
    \begin{itemize}
      \item e.g.\ software bugs; OS/user termination; OS failure.
      \item Process stops sending messages it is supposed to send.
      \item Process sends messages it is not supposed to send.
    \end{itemize}
  \item \textbf{Link failure}:
    \begin{itemize}
      \item e.g.\ cable, router, wireless, adversary.
      \item Inter-process communication failure, e.g.\ non-delivery of messages; corrupt messages; duplicates.
      \item Need for reliable protocols and secure channels.
      \item Partitioned networks.
    \end{itemize}
\end{itemize}

\subsubsection{Failure Classes}
\begin{itemize}
  \item \textbf{Process crash failure} (crash-stop failure):
    \begin{itemize}
      \item Process halts and does not perform further action.
      \item Different types:
        \begin{itemize}
          \item \textbf{Fail-stop} - can be reliably detected by other processes.
          \item \textbf{Fail-silent} - cannot be reliably detected.
          \item \textbf{Fail-noisy} - detection takes time.
          \item \textbf{Fail-recovery} - crashed processes can recover
        \end{itemize}
      \item Non-faulty processes are a \textbf{correct process}.
    \end{itemize}
  \item \textbf{Link failure}:
    \begin{itemize}
      \item Link goes down and stays down.
      \item Network may partition or remain connected.
    \end{itemize}
  \item \textbf{Omission failure}:
    \begin{itemize}
      \item Two types:
        \begin{itemize}
          \item \textbf{Send omission} - does not send all required messages.
          \item \textbf{Receive omission} - does not receive all require messages.
        \end{itemize}
    \end{itemize}
  \item \textbf{Byzantine failure} (fail-arbitrary):
    \begin{itemize}
      \item Arbitrary (or malicious) behaviour.
    \end{itemize}
\end{itemize}

\subsubsection{Communication}
\begin{itemize}
  \item \textbf{Asynchronous message passing}:
    \begin{itemize}
      \item The process sending a message continues after sending.
      \item We can build a \textbf{synchronous message passing} mechanism, e.g.\ process waits until message is delivered to the receiving process.
      \item We can build a \textbf{shared memory abstraction}.
    \end{itemize}
  \item \textbf{Reliable message communication}:
    \begin{itemize}
      \item Assume that messages sent using reliable protocol.
      \item Communications can still fail.
      \item Use TCP to send messages, simulate network failure by dropping messages in software.
    \end{itemize}
  \item \textbf{Message delays are bounded}:
    \begin{itemize}
      \item Processes timeout if message is delayed too long.
    \end{itemize}
\end{itemize}

\section{Reliable Broadcast}
We discuss algorithms for reliable broadcast in \textbf{asynchronous message-passing} distributed systems that are subject to \textbf{process failure}, we want:
\begin{itemize}
  \item To guarantee that messages are consistently delivered to processes.
  \item Agreement on delivered messages.
  \item No ordering among delivered messages.
\end{itemize}

\subsection{Structure}
Each distributed process is a set of interconnected components.
Each distributed process will typically have the same set of components.

\begin{figure}[htb!]
  \centering
  \caption{Elixir mappings.}
  \includegraphics[scale=0.3]{elixirmapping}
\end{figure}

We implement this in \textit{Elixir} where a distributed system process is 1 \textit{Elixir} node, which is many \textit{Elixir} processes.
The components are \textit{Elixir} processes which use message passing for intra-node interactions

\subsection{Assumptions}
\begin{itemize}
  \item \textbf{Asynchronous system}:
    \begin{itemize}
      \item No bound on message delays.
      \item No bound on time to execute a local process step.
      \item Time to execute a step is finite.
    \end{itemize}
  \item Processes interact by \textbf{message passing}.
  \item \textbf{Message passing is reliable}.
  \item Every process can logically communicate with every other.
  \item Number of processes fixed and known.
  \item Crashed processes do not continue.
\end{itemize}

\subsection{Classes of Broadcast}
\begin{itemize}
  \item \textbf{One shot} - each message is considered separately from others:
    \begin{itemize}
      \item Best-Effort Broadcast (BEB).
      \item Reliable Broadcast (RB).
      \item Uniform Reliable Broadcast (URB).
    \end{itemize}
  \item \textbf{Multishot} - involve all messages that are broadcast:
    \begin{itemize}
      \item FIFO Message delivery.
      \item Casual Order Message Delivery.
      \item Total Order Message Delivery.
    \end{itemize}
\end{itemize}

\subsection{Perfect Point-to-Point Links (PL)}
The distributed processes communicate with PL components.
\begin{figure}[htb!]
  \centering
  \caption{Perfect point-to-point links component.}
  \includegraphics[scale=0.3]{pl}
\end{figure}

\begin{itemize}
  \item \textbf{Reliable Delivery (L)} - if Alice and Bob are correct processes, then every message sent by Alice to Bob is eventually delivered to Bob.
  \item \textbf{No Duplication (S)} - no message is delivered to a process more than once.
  \item \textbf{No Creation (S)} - no message is delivered unless it was sent.
\end{itemize}

\subsection{Best-Effort Broadcast (BEB)}
Given a list of all processes and a message, we send the message to all processes (including ourselves) with multiple sends:
\begin{itemize}
  \item If sending is reliable, then every correct process will receive a copy, crashed processes may or may not have received a copy.
  \item The messages will be received at arbitrary times.
  \item If the sending process crashes during broadcast, some arbitrary subset of processes will receive the message.
  \item The sender does not know which processes have received the message.
\end{itemize}

\begin{figure}[htb!]
  \centering
  \caption{Best-effort broadcast component.}
  \includegraphics[scale=0.3]{beb}
\end{figure}

We assume messages are unique (e.g.\ they include a process-id and seq-no), no process broadcasts a message twice, and no two processes every broadcast the same message.

\begin{itemize}
  \item \textbf{Validity (L)} - if a correct process broadcasts a message, then every correct process eventually delivers it.
  \item \textbf{No Duplication (S)} - no message is delivered to a process more than once.
  \item \textbf{No Creation (S)} - no message is delivered unless it was broadcast.
\end{itemize}

\subsubsection{BEB Basic Broadcast}
\begin{figure}[htb!]
  \centering
  \caption{Basic broadcast.}
  \includegraphics[scale=0.3]{bebpl}
\end{figure}

\begin{itemize}
  \item BEB sends a message to each process using the PL component - this works as PL ensures all correct processes deliver messages, as long as the sender does not crash.
  \item BEB is fail-silent.
  \item $1$ broadcast step and $O(N)$ messages, where $N$ is the number of processes.
  \item BEB derives its S\&L properties from PL.
\end{itemize}

\begin{itemize}
  \item \textbf{No Duplication (S)} and \textbf{No Creation (S)} dervied from PL.
  \item \textbf{No Duplication (S)} also assumes messages are unique.
  \item \textbf{Validity (L)} derived from \textbf{Reliable Delivery (L)} in PL and the fact that the message needs to be sent to all processes.
\end{itemize}

\begin{figure}[htb!]
  \centering
  \caption{BEB code.}
  \includegraphics[scale=0.3]{bebcode}
\end{figure}

\subsection{Reliable Broadcast (RB)}
\begin{figure}[htb!]
  \centering
  \caption{Reliable broadcast component.}
  \includegraphics[scale=0.3]{rb}
\end{figure}
All correct processes will agree on the messages they deliver, even if the broadcasting process crashes while sending.

\begin{itemize}
  \item \textbf{Validity (L)}, \textbf{No Duplication (S)}, and \textbf{No Creation (S)} as in BEB.
  \item \textbf{Agreement (L)}:
    \begin{itemize}
      \item If a correct process delivers message $M$, then every correct process also delivers $M$.
      \item Validity and Agreement together provide a \textbf{Termination} property for broadcasting a message.
      \item Faulty process could deliver messages not delivered by correct processes.
    \end{itemize}
\end{itemize}

\subsubsection{Eager RB (fail-silent)}
\begin{figure}[htb!]
  \centering
  \caption{Eager RB.}
  \includegraphics[scale=0.3]{rbbeb}
\end{figure}

Every process re-broadcasts every message it delivers.
If the broadcasting process crashes, then the message will be forwarded by other processes using BEB.

At best $1$ broadcast step, at worst $O(N)$ broadcast steps if processes crash in sequence.
$O(N^2)$ messages.

\begin{itemize}
  \item \textbf{No Creation (S)} and \textbf{Validity (L)} derived from BEB.
  \item \textbf{No Duplication (S)} as messages delivered are kept track of, and messages are assumed to be unique.
  \item \textbf{Agreement (L)} is derived from \textbf{Validity (L)} of BEB, and the fact that every correct process forwards every message it delivers.
\end{itemize}

\begin{figure}[htb!]
  \centering
  \caption{Eager RB code.}
  \includegraphics[scale=0.3]{eagercode}
\end{figure}

\subsubsection{Lazy RB (fail-stop)}
\begin{figure}[htb!]
  \centering
  \caption{Lazy RB.}
  \includegraphics[scale=0.3]{lazyrb}
\end{figure}

Uses BEB, but includes a failure detector component to detect processes that have failed (and stopped).
When a crash is detected, all messages from that process are broadcast.
When a messsage is received from a crashed process then the message is broadcast, otherwise if it is a correct process it is not.

\begin{itemize}
  \item \textbf{Agreement (L)} is derived from the \textbf{Validity (L)} from BEB, that every correct process forwards every message it delivers when it detects a crashed process, and from PFD.
  \item Other properties follow as for the Eager RB.
\end{itemize}

\begin{figure}[htb!]
  \centering
  \caption{Lazy RB code, part 1.}
  \includegraphics[scale=0.3]{lazycode1}
\end{figure}

\begin{figure}[htb!]
  \centering
  \caption{Lazy RB code, part 2.}
  \includegraphics[scale=0.3]{lazycode2}
\end{figure}

\subsection{Failure Detectors}
\begin{itemize}
  \item \textbf{Perfect Failure Detector} $P$:
    \begin{itemize}
      \item Provides processes with a list of suspected (detected) processes that have crashed.
      \item Makes timing assumptions (assumes systems are not asynchronous).
      \item Never changes its view - suspects remain suspected forever.
    \end{itemize}
  \item \textbf{Eventually Perfect Failure Detector}: $\Diamond P$:
    \begin{itemize}
      \item May make mistakes but will eventually detect a crashed process.
    \end{itemize}
\end{itemize}

It has the following safety and liveness properties:
\begin{itemize}
  \item \textbf{Strong Completeness (L)} - every process that crashes will eventually be permanently suspected by every correct process.
  \item \textbf{Strong Accuracy (S)} - no process is suspected before it crashes.
  \item \textbf{Eventually Strong Accuracy (L)} - eventually no correct process is suspected.
\end{itemize}

\subsubsection{PFD Exclude on Timeout}
\begin{figure}[htb!]
  \centering
  \caption{Exclude on timeout.}
  \includegraphics[scale=0.3]{pfd}
\end{figure}

Uses PL to exchange \textit{heartbeat} messages with a timeout mechanism.
The timeout delay must be large enough for all sends to processes, processing time, and replies back.
After timeout, processes from which a reply has not been received are considered crashed, even if it is alive and the reply arrived after timeout.

\begin{itemize}
  \item \textbf{Strong Completeness (L)}:
    \begin{itemize}
      \item If a process crashes, it stops replying to heartbeat messages; no process will deliver its reply.
      \item PL ensures no message is delivered unless sent.
      \item Then every correct process will detect the crash.
    \end{itemize}
  \item \textbf{Strong Accuracy (S)}:
    \begin{itemize}
      \item A process is suspected only if no reply is delivered before timeout.
    \end{itemize}
\end{itemize}

\begin{figure}[htb!]
  \centering
  \caption{PFD code, part 1.}
  \includegraphics[scale=0.3]{pfdcode1}
\end{figure}

\begin{figure}[htb!]
  \centering
  \caption{PFD code, part 2.}
  \includegraphics[scale=0.3]{pfdcode2}
\end{figure}


\subsection{Process Configuration}
Each distributed process is in the configuration seen in figure \ref{fig:processconf}.

\begin{figure}[htb!]
  \centering
  \caption{Full configuration of a distributed process.}
  \label{fig:processconf}
  \includegraphics[scale=0.3]{processconf}
\end{figure}

\subsection{Uniform Reliable Broadcast (URB)}
\begin{figure}[htb!]
  \centering
  \caption{Uniform reliable broadcast.}
  \includegraphics[scale=0.3]{urb}
\end{figure}

\begin{itemize}
  \item \textbf{Validity (L)}, \textbf{No Duplication (S)}, and \textbf{No Creation (S)} are the same as for BEB and RB.
  \item \textbf{Uniform Agreement (L)}:
    \begin{itemize}
      \item If a process (not necessarily correct) delivers a message $M$, then every correct process will also deliver $M$.
      \item The set of messages delivered by a faulty process is always a subset of messages delivered by a correct process.
      \item Use case may be to ensure consistency in financial transactions.
    \end{itemize}
\end{itemize}

\subsubsection{Majority-Ack URB}
\begin{figure}[htb!]
  \centering
  \caption{Majority-ack URB.}
  \includegraphics[scale=0.3]{majorityack}
\end{figure}

The message is only delivered after the message has been BEB-delivered by a majority (\textit{quorum}) of processes - at least one correct process is in the majority.

This is \textbf{fail-silent} as crashes are not detected, but it is \textbf{assumed the majority are correct processes}.

If process $P$ \texttt{beb\_deliver}s message $M$, then $P$ will eventually \texttt{urb\_deliver} M.
If $P$ \texttt{beb\_broadcast}s $M$, then all correct processes \texttt{beb\_broadcast} $M$.
Assuming the majority is correct, $P$ will eventually \texttt{beb\_deliver} $M$ from the majority of processes, then it will \texttt{urb\_deliver} $M$.
Then:
\begin{itemize}
  \item \textbf{No Creation (S)} follows from the corresponding safety property of BEB.
  \item \textbf{No Duplication (S)} as the algorithm keeps track of messages that have been \texttt{urb\_deliver}ed.
  \item \textbf{Validity (L)}:
    \begin{align*}
      P \texttt{ urb\_broadcast } M &\implies P \texttt{ beb\_broadcast } M \\
                                    &\implies P \texttt{ beb\_deliver } M \\
                                    &\implies P \texttt{ urb\_deliver } M
    \end{align*}
  \item \textbf{Uniform Agreement (L)}, if $Q$ is any process that \texttt{urb\_deliver}s $M$, then:
    \begin{itemize}
      \item $Q$ \texttt{beb\_deliver}ed $M$ from the majority of processes, and at least $1$ correct process \texttt{beb\_broadcast}ed $M$ (assumption).
      \item THen all correct processes eventually \texttt{beb\_deliver} $M$, and will also eventually \texttt{urb\_deliver} $M$.
    \end{itemize}
\end{itemize}

\begin{figure}[htb!]
  \centering
  \caption{Majority-ack URB code, part 1.}
  \includegraphics[scale=0.3]{urbcode1}
\end{figure}

\begin{figure}[htb!]
  \centering
  \caption{Majority-ack URB code, part 2.}
  \includegraphics[scale=0.3]{urbcode2}
\end{figure}

\begin{figure}[htb!]
  \centering
  \caption{Majority-ack URB code, part 3.}
  \includegraphics[scale=0.3]{urbcode3}
\end{figure}

\section{FIFO, Causal, and Total Order Broadcast}
\begin{itemize}
  \item \textbf{First In, First Out (FIFO)} - messages broadcast by a process are delivered in their broadcast order.
  \item \textbf{Causal Order (CO)} - messages broadcast by a process are delivered in their \textit{causal} order.
  \item \textbf{Total Order (TO)} - all correct processes deliver the same (global) sequence of messages, impossible in an asynchronous system.
\end{itemize}

\subsection{FIFO Regular RB (FRB)}
\begin{figure}[htb!]
  \centering
  \caption{FRB component.}
  \includegraphics[scale=0.3]{fifo}
\end{figure}

FIFO regular reliable broadcast has the same reliability properties as RB, plus the ordering property that if a process broadcasts $M1$ before it broadcasts $M2$, then all \textbf{correct processes} will deliver $M1$ before $M2$.
This does not affect the messages of different senders.

\begin{figure}[htb!]
  \centering
  \caption{FRB code, part 1.}
  \includegraphics[scale=0.3]{frbcode1}
\end{figure}

\begin{figure}[htb!]
  \centering
  \caption{FRB code, part 2.}
  \includegraphics[scale=0.3]{frbcode2}
\end{figure}

\subsection{Causal Order RB (CRB)}
\begin{figure}[htb!]
  \centering
  \caption{CRB component.}
  \includegraphics[scale=0.3]{crb}
\end{figure}

The \textbf{causal order relation} $m1 \rightarrow m2$ states that $m1$ may have caused $m2$ if the following apply:
\begin{itemize}
  \item \textbf{FIFO order} - Alice broadcasts $m1$, and later $m2$.
  \item \textbf{Local order} - Alice delivers $m1$, and later broadcasts $m2$.
  \item \textbf{Transitivity} - if there is a message $m3$ such that $m1 \rightarrow m3$, and $m3 \rightarrow m2$.
\end{itemize}

The \textbf{causal delivery property} ensures that if any process delivers $m2$, it must have previously delivered every message $m1$ such that $m1 \rightarrow m2$, thus ensuring that ``cause-effect'' relations are respected.

We never delay \texttt{crb\_deliver}ing a message - if we receive $m2$ and $m1$ was in the past, then we deliver $m1$ then $m2$ in causal order.
If we then receive $m1$ again, we can safely discard it.
\begin{itemize}
  \item \textbf{No Duplication (S)}, \textbf{No Creation (S)}, \textbf{Validity (L)}, and \textbf{Uniform Agreement (L)} are derived from the URB.
  \item \textbf{Causal Delivery (S)} is ensured by every message carrying its causally past messages, and by forcing them to be delivered before the message.
\end{itemize}
Carrying the entirety of the message's past means the overall message size can grow very large - we can optimize by purging messages from \texttt{past}.

\begin{figure}[htb!]
  \centering
  \caption{CRB code, part 1.}
  \includegraphics[scale=0.3]{crbcode1}
\end{figure}

\begin{figure}[htb!]
  \centering
  \caption{CRB code, part 2.}
  \includegraphics[scale=0.3]{crbcode2}
\end{figure}

\subsubsection{CRB with Vector Clocks}
We can use \textbf{vector clocks} to avoid storing past messages.
The vector clock (an array of sequence numbers) indicates the number of messages from each process that have been delivered.
Each process also maintains a count of the number of messages it has broadcast.

When a process broadcasts, it includes its vector clock with its own entry set to the broadcast's sequence number.
The receiving process, before delivering a message $M$, must compare the vector clock of the message with its own, the difference is the number of messages that must be delivered before $M$ - the process must defer delivering if necessary.

\begin{figure}[htb!]
  \centering
  \caption{CRB with vector clock code, part 1.}
  \includegraphics[scale=0.3]{vccode1}
\end{figure}

\begin{figure}[htb!]
  \centering
  \caption{CRB with vector clock code, part 2.}
  \includegraphics[scale=0.3]{vccode2}
\end{figure}

\subsection{Total Order Broadcast}
All processes must deliver all messages in the same order.
Causality or FIFO does not need to be respected but can be made to do so.

\subsubsection{Uniform Total Order Broadcast (TOURB)}
We require the 4 properties of URB, plus the following:
If $P$ is a correct process and delivers $M1$ without having delivered $M2$, no correct process delivers $M2$ before $M1$.

This is equivalent to the consensus problem - solving this problem solves the total order problem.
However, this problem cannot be solved in a completely asynchronous system.

\end{document}

